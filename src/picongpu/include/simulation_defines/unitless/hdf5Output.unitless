/**
 * Copyright 2013 Axel Huebl, Ren√© Widera
 *
 * This file is part of PIConGPU. 
 * 
 * PIConGPU is free software: you can redistribute it and/or modify 
 * it under the terms of the GNU General Public License as published by 
 * the Free Software Foundation, either version 3 of the License, or 
 * (at your option) any later version. 
 * 
 * PIConGPU is distributed in the hope that it will be useful, 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 * GNU General Public License for more details. 
 * 
 * You should have received a copy of the GNU General Public License 
 * along with PIConGPU.  
 * If not, see <http://www.gnu.org/licenses/>. 
 */ 
 


#pragma once

#include <boost/mpl/vector.hpp>
#include <boost/mpl/pair.hpp>

#include "fields/FieldE.hpp"
#include "fields/FieldB.hpp"
#include "fields/FieldJ.hpp"
#include "fields/FieldTmp.hpp"

#include "particles/Species.hpp"

#include "particles/particleToGrid/energyDensity.kernel"

#include "particles/boostExtension/JoinVectors.hpp"

namespace picongpu
{
    /** Note: you will need at least FieldE and FieldB for restart
     *       capability!
     *  Possible fields: FieldE, FieldB, FieldJ
     */
    typedef boost::mpl::vector<FieldE, FieldB> NativeHdf5OutputFields;
    
    /** TimeAvg Fields
     * \todo Reduce/Avg on host-side RAM with an analyser
     */
    
    /** FieldTmp output (calculated at runtime)
     */
    using namespace particleToGrid;
    
    typedef ComputeEnergyDensityPerFrame<
            speciesParticleShape::ParticleShape::ChargeAssignment,
            ComputeEnergyDensityOptions::calcDensity
        > TmpParticleDensity;
    
    typedef ComputeEnergyDensityPerFrame<
            speciesParticleShape::ParticleShape::ChargeAssignment,
            ComputeEnergyDensityOptions::calcEnergyDensity
        > TmpParticleEnergyDensity;
    
    typedef ComputeEnergyDensityPerFrame<
            particleShape::Counter::ChargeAssignment,
            ComputeEnergyDensityOptions::calcCounter
        > TmpParticleCounter;
    
    
    /** Define which operation is used to fill up FieldTmp
     * 
     * This is better than use of boost::mtl::pair because
     * we can use this special struct to define functors 
     * only for FieldTmp. If we create a second FieldTmp, for example 
     * with three components, we can create a new struct (like this)
     * and build a special functor to handle the type.
     */
    template<typename TSolver,typename TSpecies>
    struct TmpFieldOperation
    {
        typedef TSolver Solver;
        typedef TSpecies Species;
    };

    /** List of solver which use TmpField and electons*/
    typedef boost::mpl::vector<
#if (ENABLE_ELECTRONS == 1)
                TmpFieldOperation< TmpParticleDensity, PIC_Electrons > ,
                TmpFieldOperation< TmpParticleEnergyDensity, PIC_Electrons >
#endif
    > PluginsHdf5OutputFieldsElectrons;

    /** List of solver which use TmpField andions*/
    typedef boost::mpl::vector<
#if (ENABLE_IONS == 1)
                TmpFieldOperation< TmpParticleDensity, PIC_Ions >,
                TmpFieldOperation< TmpParticleEnergyDensity, PIC_Ions >
#endif
    > PluginsHdf5OutputFieldsIons;
    
    
    /** This list is use to dump fields to HDf5. */
    typedef JoinVectors<NativeHdf5OutputFields,
            PluginsHdf5OutputFieldsElectrons,
            PluginsHdf5OutputFieldsIons
            >::type Hdf5OutputFields;
}
