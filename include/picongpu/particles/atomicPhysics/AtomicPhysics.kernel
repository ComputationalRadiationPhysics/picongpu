/* Copyright 2013-2020 Axel Huebl, Felix Schmitt, Heiko Burau, Rene Widera,
 *                     Richard Pausch, Alexander Debus, Marco Garten,
 *                     Benjamin Worpitz, Alexander Grund, Sergei Bastrakov,
 *                     Brian Marre
 *
 * This file is part of PIConGPU.
 *
 * PIConGPU is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PIConGPU is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PIConGPU.
 * If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once

#include "picongpu/simulation_defines.hpp"
#include "picongpu/particles/atomicPhysics/electronDistribution/histogram2/Histogram.hpp"
#include "picongpu/particles/atomicPhysics/FillHistogram.hpp"

#include <pmacc/attribute/FunctionSpecifier.hpp>

// modules necessary for random number generators from pmacc
// #include <pmacc/random/methods/methods.hpp>
// #include <pmacc/random/distributions/Uniform.hpp>
// #include <pmacc/random/RNGProvider.hpp>

#include <cstdint>

namespace picongpu
{
namespace particles
{
namespace atomicPhysics
{


    template<
        uint32_t T_numWorkers,
        uint32_t T_maxNumBins
    >
    struct AtomicPhysicsKernel
    {

        template<
            typename T_Acc,
            typename T_ElectronBox,
            typename T_IonBox,
            typename T_Mapping
        >
        HDINLINE void operator()(
            T_Acc const & acc,
            T_ElectronBox electronBox,
            T_IonBox ionBox,
            T_Mapping mapper,
            float_X binWidth
        ) const
        {
            // we assume 1d thread indices
            // thread index inside a block
            uint32_t const workerIdx = cupla::threadIdx( acc ).x;

            // Create and initialize a histogram on shared memory
            using Histogram = electronDistribution::histogram2::Histogram<
                T_maxNumBins,
                T_numWorkers
            >;
            PMACC_SMEM(
                acc, // mandatory first parameter
                histogram, // variable name
                Histogram // variable type
            );
            if( workerIdx == 0 )
                histogram.setWidth( binWidth );
            cupla::__syncthreads( acc );

            /// Call another "kernel" to fill the histogram
            fillHistogram< T_numWorkers >(
                acc,
                electronBox,
                mapper,
                &histogram
            );

            /// Call another "kernel" to solve the rate equation

            /// Call another "kernel" to backpropagate


        }
    };

        // get specialisation of ConfigNumber class used in this species
        //using IonSpeciesAtomicConfigNumber =
        //    typename pmacc::particles::traits::ResolveAliasFromSpecies<
        //        IonSpecies,
        //        atomicConfigNumber< >
        //        /* atomicConfigNumber is alias(interface name) for specific
        //        specialisation of ConfigNumber of this specific species*/
        //    >::type;

        /* get T_DataType used as parameter in ConfigNumber.hpp via public
        typedef in class */
       // using ConfigNumberDataType = uint32_t;
            ///typename IonSpeciesAtomicConfigNumber::DataType;




    /* for use with pmacc
        // random number generator(RNG) Factory as defined in random.param
        using RNGFactory = pmacc::random::RNGProvider<
            simDim,
            random::Generator
            >;
        using DistributionInt = pmacc::random::distributions::Uniform<
            ConfigNumberDataType
            >;
        using DistributionFloat = pmacc::random::distributions::Uniform<
            double
            >;
        // type of random number Generator extracted from RNGFactory
        using RandomGen = typename RNGFactory::GetRandomType<
            DistributionInt
            >::type;
        using RandomGen = typename RNGFactory::GetRandomType<
            DistributionFloat
            >::type;

        // actual random number Generator defined as attribute and initialised
        RandomGen randomGenInt = RNGFactory::createRandom< DistributionInt >();
        RandomGen randomGenFloat = RNGFactory::createRandom< DistributionFloat >();
    */


        // Attribute definitions:

        // RateMatrix encapsulated call to flylite,
        // not implemented yet
        ////RateMatrix rateMatrix;
        // random number Generators
        //std::uniform_int_distribution<ConfigNumberDataType> randomIntGen;
        //std::uniform_real_distribution<float> randomFloatGen;



        // Process ions and electrons: here the boxes contain all supercells

            // For the CPU version, loop over all supercells manually,
            // in a real kernel this will be done in parallel one supercell per block
            //auto const guardingSuperCells = mapper.getGuardingSuperCells();
            //auto const superCellsCount =
            //    mapper.getGridSuperCells() - 2 * guardingSuperCells;
            //auto const numSuperCells = superCellsCount.productOfComponents();

            //{
            //    auto const idxWithGuard = DataSpaceOperations< simDim >::map(
            //        superCellsCount,
            //        supercellLinearIdx
            //    ) + guardingSuperCells;
            //    processSupercell(
            //        idxWithGuard,
            //        ionBox,
            //        electronBox,
            //        mapper
            //    );
            //}


        // Process ions and electrons in the supercell with given index
      
            // The real kernel will essentially only have this part,
            // just start with selecting a supercell based on block index

            // initialise randomGen with index of SuperCell
            /// ask Sergei once more, wether possible
            ///this->randomGen.init(idx);

        //    auto electronFrame = electronBox.getLastFrame( idx );
        //    // Iterate over ions frames
        //    auto ionFrame = ionBox.getLastFrame( idx );
        //    auto ionsInFrame = ionBox.getSuperCell( idx ).getSizeLastFrame();
        //    while( ionFrame.isValid() )
        //    {
        //        // Iterate over ions in a frame, for now sequentially
        //        // (in the kernel just this loop and index will change)
        //        for( int ionIdx = 0; ionIdx < ionsInFrame; ionIdx++ )
        //        {
        //            auto ion = ionFrame[ ionIdx ];
        //            //auto electron = electronFrame[ 0 ];

        //            /// Here implement everything using variables ion and electron
        //            /// that represent the selected pair

        //            float timeRemaining;
        //            float rate;
        //            float probability;

        //            using ConfigNumberDataType = uint32_t;
        //            ConfigNumberDataType newState;
        //            ConfigNumberDataType randomNumber;
        //            // ion[atomicConfigNumber_].configNumber;

        //            timeRemaining = static_cast< double >(
        //                picongpu::SI::DELTA_T_SI
        //            );

        //            while ( timeRemaining > 0)
        //            {
        //                // note: removed as the use of standard rng was not correct
        //                ///this->randomIntGen();
        //                newState = 123; 
    
        //                // TODO: implement rate matrix calculation
        //                rate = 1.0_X;
        //                    ////this->rateMatrix( newState, ion[atomicConfigNumber_].configNumber );
        //                probability = rate * timeRemaining;
        //                if ( probability >= 1 )
        //                {
        //                    ion[ atomicConfigNumber_ ].configNumber = newState;
        //                    timeRemaining -= 1/rate;
        //                }
        //                else
        //                {
        //                    if ( /*this->randomFloatGen()*/ 0.1_X <= probability )
        //                    {
        //                        ion[ atomicConfigNumber_ ].configNumber = newState;
        //                    }
        //                }
        //            }

        //        }
        //        ionFrame = ionBox.getPreviousFrame( ionFrame );
        //        ionsInFrame = pmacc::math::CT::volume< SuperCellSize >::type::value;
        //    }
        //}

} // namespace atomicPhysics
} // namespace particles

namespace traits
{

    /** specialization of the UsesRNG trait
    * --> atomicPhysics module uses random number generation
    */
    template<
        uint32_t T_numWorkers,
        uint32_t T_maxNumBins
    >
    struct UsesRNG<
        particles::atomicPhysics::AtomicPhysicsKernel< T_numWorkers, T_maxNumBins >
    > : public boost::true_type
    {
    };
} // namespace traits

} // namespace picongpu
