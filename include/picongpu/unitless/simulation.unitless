/* Copyright 2013-2023 Felix Schmitt, Heiko Burau, Rene Widera,
 *                     Benjamin Worpitz
 *
 * This file is part of PIConGPU.
 *
 * PIConGPU is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PIConGPU is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PIConGPU.
 * If not, see <http://www.gnu.org/licenses/>.
 */


#pragma once

#include <pmacc/math/ConstVector.hpp>
#include <pmacc/math/Vector.hpp>

namespace picongpu
{
    struct Sim
    {
        struct PicUnits
        {
            constexpr float3_X getCellSize() const
            {
                return float3_X(si.getCellSize() / unit.length());
            }

            constexpr float_X getDt() const
            {
                return float_X(si.getDt() / unit.time());
            }

            constexpr float_X getSpeedOfLight() const
            {
                return float_X(si.getSpeedOfLight() / unit.speed());
            }

            constexpr float_X getBaseMass() const
            {
                return float_X(si.getBaseMass() / unit.mass());
            }

            constexpr float_X getBaseCharge() const
            {
                return float_X(si.getBaseCharge() / unit.charge());
            }

            constexpr float_X getBaseDensity() const
            {
                return float_X(si.getBaseDensity() * unit.length() * unit.length() * unit.length());
            }

            constexpr float_X getElectronMass() const
            {
                return float_X(si.getElectronMass() / unit.mass());
            }

            constexpr float_X getElectronCharge() const
            {
                return float_X(si.getElectronCharge() / unit.charge());
            }
        };
        struct SiUnits
        {
            /** unit: meter */
            constexpr float3_64 getCellSize() const
            {
                return {SI::CELL_WIDTH_SI, SI::CELL_HEIGHT_SI, SI::CELL_DEPTH_SI};
            }

            /** unit: seconds */
            constexpr float_64 getDt() const
            {
                return SI::DELTA_T_SI;
            }

            /** unit: meter / seconds */
            constexpr float_64 getSpeedOfLight() const
            {
                return SI::SPEED_OF_LIGHT_SI;
            }

            /** Base density in particles per m^3 in the density profiles.
             *
             * This is often taken as reference maximum density in normalized profiles.
             * Individual particle species can define a `densityRatio` flag relative
             * to this value.
             *
             * unit: ELEMENTS/m^3
             */
            constexpr float_64 getBaseDensity() const
            {
                return SI::BASE_DENSITY_SI;
            }

            /** base particle mass
             *
             * reference for massRatio in speciesDefinition.param
             *
             * unit: kg
             */
            constexpr float_64 getBaseMass() const
            {
                return SI::BASE_MASS_SI;
            }
            /** base particle charge
             *
             * reference for chargeRatio in speciesDefinition.param
             *
             * unit: C
             */
            constexpr float_64 getBaseCharge() const
            {
                return SI::BASE_CHARGE_SI;
            }

            /** Electron properties
             * unit: kg
             */
            constexpr float_64 getElectronMass() const
            {
                return SI::ELECTRON_MASS_SI;
            }
            /** Electron properties
             * unit: C
             */
            constexpr float_64 getElectronCharge() const
            {
                return SI::ELECTRON_CHARGE_SI;
            }
        };
        struct Units
        {
            constexpr float_64 length() const
            {
                return time() * speed();
            }
            constexpr float_64 time() const
            {
                return SI::DELTA_T_SI;
            }
            constexpr float_64 speed() const
            {
                return si.getSpeedOfLight();
            }
            constexpr float_64 mass() const
            {
                return si.getBaseMass() * typicalNumParticlesPerMacroParticle();
            }
            constexpr float_64 charge() const
            {
                return -1.0 * si.getBaseCharge() * typicalNumParticlesPerMacroParticle();
            }
            constexpr float_64 energy() const
            {
                return mass() * length() * length() / (time() * time());
            }
            constexpr float_64 eField() const
            {
                return 1.0 / (time() * time() / mass() / length() * length());
            }
            constexpr float_64 bField() const
            {
                return mass() / (time() * charge());
            }
            /** Typical number of particles per macro particle (= typical macro particle weighting)
             *  unit: none
             */
            constexpr float_64 typicalNumParticlesPerMacroParticle() const
            {
                return (si.getBaseDensity() * si.getCellSize().productOfComponents())
                    / float_64(getTypicalNumParticlesPerCell());
            }
        };

        static constexpr uint32_t getTypicalNumParticlesPerCell()
        {
            return TYPICAL_PARTICLES_PER_CELL;
        }

        static constexpr PicUnits pic{};
        static constexpr SiUnits si{};
        static constexpr Units unit{};
    };

    constexpr auto sim = Sim{};


    // normed grid parameter
    constexpr float_X DELTA_T = sim.pic.getDt();
    constexpr float_X CELL_HEIGHT = sim.pic.getCellSize().y();
    constexpr float_X CELL_DEPTH = sim.pic.getCellSize().z();

    // only used for CFL checks
    constexpr float_X INV_CELL2_SUM
        = (1.0 / (sim.pic.getCellSize().shrink<simDim>() * sim.pic.getCellSize().shrink<simDim>())).sumOfComponents();

} // namespace picongpu
