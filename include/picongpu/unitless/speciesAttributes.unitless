/* Copyright 2013-2019 Rene Widera, Felix Schmitt, Axel Huebl,
 *                     Alexander Grund
 *
 * This file is part of PIConGPU.
 *
 * PIConGPU is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PIConGPU is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PIConGPU.
 * If not, see <http://www.gnu.org/licenses/>.
 */

#pragma once

#include <vector>
#include "picongpu/traits/Unit.hpp"
#include "picongpu/traits/UnitDimension.hpp"
#include "picongpu/traits/SIBaseUnits.hpp"
#include "picongpu/particles/traits/MacroWeighted.hpp"
#include "picongpu/particles/traits/WeightingPower.hpp"


/** \file speciesAttributes.unitless
 *
 * This file describes the particle attributes defined in
 * \see speciesAttributes.param of a particle species.
 * Each particle attribute needs to implement the following traits
 *   - `Unit`
 *      - conversion between PIConGPU units and SI
 *      - \see traits/Unit.hpp
 *      - \see https://git.io/vriio
 *   - `UnitDimension`
 *      - powers of the seven SI base units
 *      - \see traits/UnitDimension.hpp
 *      - \see https://git.io/vriio
 *   - `MacroWeighted`
 *      - attribute is weighted to a macro-particle?
 *      - \see particles/traits/MacroWeighted.hpp
 *      - \see https://git.io/vwlWa
 *   - `WeightingPower`
 *      - attribute is different for macro and real particles?
 *        describe how it scales with the weighting
 *      - \see particles/traits/WeightingPower.hpp
 *      - \see https://git.io/vwlWa
 */
namespace picongpu
{
namespace traits
{

template<typename T_Type>
struct Unit<position<T_Type> >
{
    static std::vector<double> get()
    {
        std::vector<double> unit(simDim);
        /* in-cell position needs two transformations to get to SI:
           in-cell [0;1) -> dimensionless scaling to grid -> SI
        */
        for(uint32_t i=0;i<simDim;++i)
            unit[i]=cellSize[i]*UNIT_LENGTH;

        return unit;
    }
};
template<typename T_Type>
struct UnitDimension<position<T_Type> >
{
    static std::vector<float_64> get()
    {
        /* L, M, T, I, theta, N, J
         *
         * position is in meter: m
         *   -> L
         */
        std::vector<float_64> unitDimension( NUnitDimension, 0.0 );
        unitDimension.at(SIBaseUnits::length) = 1.0;

        return unitDimension;
    }
};
template<typename T_Type>
struct MacroWeighted<position<T_Type> >
{
    // the position is identical and can not be scaled by weightings
    static bool get()
    {
        return false;
    }
};
template<typename T_Type>
struct WeightingPower<position<T_Type> >
{
    // x * weighting^0 == x: same for real and macro particle
    static float_64 get()
    {
        return 0.0;
    }
};

template<>
struct Unit<radiationMask>
{
    // unitless and not scaled by a factor: by convention 1.0
    static std::vector<double> get()
    {
        std::vector<double> unit( 1, 1.0 );
        return unit;
    }
};
template<>
struct UnitDimension<radiationMask>
{
    static std::vector<float_64> get()
    {
        // radiationMask is unitless
        std::vector<float_64> unitDimension( NUnitDimension, 0.0 );

        return unitDimension;
    }
};
template<>
struct MacroWeighted<radiationMask>
{
    // identical and can not be scaled by weightings
    static bool get()
    {
        return false;
    }
};
template<>
struct WeightingPower<radiationMask>
{
    // flag * weighting^0 == flag: same for real and macro particle
    static float_64 get()
    {
        return 0.0;
    }
};

template<>
struct Unit<momentum>
{
    static std::vector<double> get()
    {
        const uint32_t components = GetNComponents<typename momentum::type>::value;

        std::vector<double> unit(components);
        for(uint32_t i=0;i<components;++i)
            unit[i]=UNIT_MASS*UNIT_SPEED;

        return unit;
    }
};
template<>
struct UnitDimension<momentum>
{
    static std::vector<float_64> get()
    {
        /* L, M, T, I, theta, N, J
         *
         * momentum is in mass times speed: kg * m / s
         *   -> L * M * T^-1
         */
        std::vector<float_64> unitDimension( NUnitDimension, 0.0 );
        unitDimension.at(SIBaseUnits::length) =  1.0;
        unitDimension.at(SIBaseUnits::mass)   =  1.0;
        unitDimension.at(SIBaseUnits::time)   = -1.0;

        return unitDimension;
    }
};
template<>
struct MacroWeighted<momentum>
{
    // we currently push macro particle momentums
    static bool get()
    {
        return true;
    }
};
template<>
struct WeightingPower<momentum>
{
    /* px * weighting^1 == px * weighting: momentum is contributed linearly
     * in the macro-particle ensemble
     */
    static float_64 get()
    {
        return 1.0;
    }
};

template<>
struct Unit<momentumPrev1>
{
    static std::vector<double> get()
    {
        const uint32_t components = GetNComponents<typename momentumPrev1::type>::value;

        std::vector<double> unit(components);
        for(uint32_t i=0;i<components;++i)
            unit[i]=UNIT_MASS*UNIT_SPEED;

        return unit;
    }
};
template<>
struct UnitDimension<momentumPrev1>
{
    static std::vector<float_64> get()
    {
        /* L, M, T, I, theta, N, J
         *
         * momentum is in mass times speed: kg * m / s
         *   -> L * M * T^-1
         */
        std::vector<float_64> unitDimension( NUnitDimension, 0.0 );
        unitDimension.at(SIBaseUnits::length) =  1.0;
        unitDimension.at(SIBaseUnits::mass)   =  1.0;
        unitDimension.at(SIBaseUnits::time)   = -1.0;

        return unitDimension;
    }
};
template<>
struct MacroWeighted<momentumPrev1>
{
    // we currently push macro particle momentums
    static bool get()
    {
        return true;
    }
};
template<>
struct WeightingPower<momentumPrev1>
{
    /* px_real * weighting^1 == px_macro * weighting: momentum is contributed
     * linearly in the macro-particle ensemble
     */
    static float_64 get()
    {
        return 1.0;
    }
};

template<>
struct Unit<weighting>
{
    // unitless and not scaled by a factor: 1.0
    static std::vector<double> get()
    {
        std::vector<double> unit( 1, 1.0 );
        return unit;
    }
};
template<>
struct UnitDimension<weighting>
{
    static std::vector<float_64> get()
    {
        // weighting is unitless
        std::vector<float_64> unitDimension( NUnitDimension, 0.0 );

        return unitDimension;
    }
};
template<>
struct MacroWeighted<weighting>
{
    // the weighting attribute is an attribute of the macro particle
    static bool get()
    {
        return true;
    }
};
template<>
struct WeightingPower<weighting>
{
    /* 1 * weighting^1 == weighting: real particles contibute linearily
     * to the macro particle weighting
     */
    static float_64 get()
    {
        return 1.0;
    }
};


template<>
struct Unit<voronoiCellId>
{
    // unitless and not scaled by a factor: by convention 1.0
    static std::vector<double> get()
    {
        std::vector<double> unit( 1, 1.0 );
        return unit;
    }
};
template<>
struct UnitDimension<voronoiCellId>
{
    static std::vector<float_64> get()
    {
        // voronoiCellId is unitless
        std::vector<float_64> unitDimension( NUnitDimension, 0.0 );

        return unitDimension;
    }
};
template<>
struct MacroWeighted<voronoiCellId>
{
    // the voronoiCellId attribute is not a physical parameter
    static bool get()
    {
        return false;
    }
};
template<>
struct WeightingPower<voronoiCellId>
{
    // the voronoiCellId attribute is not a physical parameter
    static float_64 get()
    {
        return 0.0;
    }
};

template<>
struct Unit<probeE>
{
    static std::vector<double> get()
    {
        uint32_t const components = 3u;

        std::vector< double > const unit( components, UNIT_EFIELD);

        return unit;
    }
};
template<>
struct UnitDimension<probeE>
{
    static std::vector<float_64> get()
    {
       /* L, M, T, I, theta, N, J
        *
        * E is in volts per meters: V / m = kg * m / (A * s^3)
        *   -> L * M * T^-3 * I^-1
        */
       std::vector<float_64> unitDimension( 7, 0.0 );
       unitDimension.at(SIBaseUnits::length) =  1.0;
       unitDimension.at(SIBaseUnits::mass)   =  1.0;
       unitDimension.at(SIBaseUnits::time)   = -3.0;
       unitDimension.at(SIBaseUnits::electricCurrent) = -1.0;

       return unitDimension;
    }
};
template<>
struct MacroWeighted<probeE>
{
    static bool get()
    {
        return false;
    }
};
template<>
struct WeightingPower<probeE>
{
    // local electric fields do not scale with weighting
    static float_64 get()
    {
        return 0.0;
    }
};

template<>
struct Unit<probeB>
{
    static std::vector<double> get()
    {
        uint32_t const components = 3u;

        std::vector< double > const unit( components, UNIT_BFIELD);

        return unit;
    }
};
template<>
struct UnitDimension<probeB>
{
    static std::vector<float_64> get()
    {
       /* L, M, T, I, theta, N, J
        *
        * B is in Tesla : kg / (A * s^2)
        *   -> M * T^-2 * I^-1
        */
       std::vector<float_64> unitDimension( 7, 0.0 );
       unitDimension.at(SIBaseUnits::mass) =  1.0;
       unitDimension.at(SIBaseUnits::time) = -2.0;
       unitDimension.at(SIBaseUnits::electricCurrent) = -1.0;

       return unitDimension;
    }
};
template<>
struct MacroWeighted<probeB>
{
    static bool get()
    {
        return false;
    }
};
template<>
struct WeightingPower<probeB>
{
    // local magnetic fields do not scale with weighting
    static float_64 get()
    {
        return 0.0;
    }
};

template<>
struct Unit<particleId>
{
    // unitless and not scaled by a factor: by convention 1.0
    static std::vector<double> get()
    {
        std::vector<double> unit( 1, 1.0 );
        return unit;
    }
};
template<>
struct UnitDimension<particleId>
{
    static std::vector<float_64> get()
    {
        // unitless
        return std::vector<float_64>( NUnitDimension, 0.0 );
    }
};
template<>
struct MacroWeighted<particleId>
{
    // we can only follow maro particles via ids
    static bool get()
    {
        return false;
    }
};
template<>
struct WeightingPower<particleId>
{
    // particle ids do not scale with weighting
    static float_64 get()
    {
        return 0.0;
    }
};

template<>
struct Unit<totalCellIdx>
{
    /* unitless index and not scaled by a factor: by convention 1.0 */
    static std::vector<double> get()
    {
        std::vector<double> unit( simDim, 1.0 );
        return unit;
    }
};
template<>
struct UnitDimension<totalCellIdx>
{
    static std::vector<float_64> get()
    {
        /* totalCellIdx is a cell index and therefore unitless
         */
        std::vector<float_64> unitDimension( NUnitDimension, 0.0 );

        return unitDimension;
    }
};
template<>
struct MacroWeighted<totalCellIdx>
{
    // the cell idx is identical and can not be scaled by weightings
    static bool get()
    {
        return false;
    }
};
template<>
struct WeightingPower<totalCellIdx>
{
    // idx * weighting^0 == idx: same for real and macro particle
    static float_64 get()
    {
        return 0.0;
    }
};

template<>
struct Unit<boundElectrons>
{
    // unitless and not scaled by a factor: 1.0
    static std::vector<double> get()
    {
        std::vector<double> unit( 1, 1.0 );
        return unit;
    }
};
template<>
struct UnitDimension<boundElectrons>
{
    static std::vector<float_64> get()
    {
        // boundElectrons is unitless
        std::vector<float_64> unitDimension( NUnitDimension, 0.0 );

        return unitDimension;
    }
};
template<>
struct MacroWeighted<boundElectrons>
{
    // bound electrons are counted for a single real ion
    static bool get()
    {
        return false;
    }
};
template<>
struct WeightingPower<boundElectrons>
{
    /* #e-_real * weighting^1 == #e-_macro: bound electrons are contributed
     * linearly from the underlying real particles
     */
    static float_64 get()
    {
        return 1.0;
    }
};

template<>
struct Unit<superconfig>
{
    // unitless and not scaled by a factor: 1.0
    static std::vector<double> get()
    {
        return std::vector<double>( picongpu::flylite::populations, 1.0 );
    }
};
template<>
struct UnitDimension<superconfig>
{
    static std::vector<float_64> get()
    {
        // superconfig is unitless
        std::vector<float_64> unitDimension( NUnitDimension, 0.0 );

        return unitDimension;
    }
};
template<>
struct MacroWeighted<superconfig>
{
    // represented by (1) or (weighted) ions???
    static bool get()
    {
        return false;
    }
};
template<>
struct WeightingPower<superconfig>
{
    static float_64 get()
    {
        return 1.0;
    }
};

} // namespace traits
} // namespace picongpu
