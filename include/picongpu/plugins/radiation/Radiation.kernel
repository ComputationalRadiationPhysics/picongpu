/* Copyright 2013-2021 Axel Huebl, Heiko Burau, Rene Widera, Richard Pausch,
 *                     Klaus Steiniger, Felix Schmitt, Benjamin Worpitz
 *
 * This file is part of PIConGPU.
 *
 * PIConGPU is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * PIConGPU is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with PIConGPU.
 * If not, see <http://www.gnu.org/licenses/>.
 */


#pragma once


#include "picongpu/simulation_defines.hpp"

#include <pmacc/dimensions/DataSpaceOperations.hpp>
#include <pmacc/mappings/kernel/AreaMapping.hpp>


#include "picongpu/plugins/radiation/VectorTypes.hpp"
#include "picongpu/plugins/radiation/check_consistency.hpp"
#include "picongpu/plugins/radiation/particle.hpp"
#include "picongpu/plugins/radiation/amplitude.hpp"
#include "picongpu/plugins/radiation/calc_amplitude.hpp"
#include "picongpu/plugins/radiation/windowFunctions.hpp"
#include "picongpu/plugins/radiation/GetRadiationMask.hpp"

#include <pmacc/mpi/reduceMethods/Reduce.hpp>
#include <pmacc/mpi/MPIReduce.hpp>
#include <pmacc/nvidia/functors/Add.hpp>
#include <pmacc/nvidia/atomic.hpp>
#include <pmacc/memory/shared/Allocate.hpp>
#include <pmacc/memory/Array.hpp>
#include <pmacc/mappings/threads/ForEachIdx.hpp>
#include <pmacc/mappings/threads/IdxConfig.hpp>


#include "picongpu/plugins/radiation/nyquist_low_pass.hpp"

#include "picongpu/plugins/radiation/radFormFactor.hpp"
#include "sys/stat.h"

#include <string>
#include <iostream>
#include <fstream>
#include <cstdlib>

namespace picongpu
{
    namespace plugins
    {
        namespace radiation
        {
            /** calculate the radiation of a species
             *
             * If \p T_dependenciesFulfilled is false a dummy kernel without functionality is created
             *
             * @tparam T_numWorkers number of workers
             */
            template<uint32_t T_numWorkers>
            struct KernelRadiationParticles
            {
                /**
                 * The radiation kernel calculates for all particles on the device the
                 * emitted radiation for every direction and every frequency.
                 * The parallelization is as follows:
                 *  - There are as many Blocks of threads as there are directions for which
                 *    radiation needs to be calculated. (A block of threads shares
                 *    shared memory)
                 *  - The number of threads per block is equal to the number of cells per
                 *    super cells which is also equal to the number of particles per frame
                 *
                 * The procedure starts with calculating unique ids for the threads and
                 * initializing the shared memory.
                 * Then a loop over all super cells starts.
                 * Every thread loads a particle from that super cell and calculates its
                 * retarded time and its real amplitude (both is dependent of the direction).
                 * For every Particle
                 * exists therefor a unique space within the shared memory.
                 * After that, a thread calculates for a specific frequency the emitted
                 * radiation of all particles.
                 * @param pb
                 * @param radiation
                 * @param globalOffset
                 * @param currentStep
                 * @param mapper
                 * @param freqFkt
                 * @param simBoxSize
                 */
                template<typename ParBox, typename DBox, typename Mapping, typename T_Acc>
                DINLINE
                    /*__launch_bounds__(256, 4)*/
                    void
                    operator()(
                        T_Acc const& acc,
                        ParBox pb,
                        DBox radiation,
                        DataSpace<simDim> globalOffset,
                        uint32_t currentStep,
                        Mapping mapper,
                        radiation_frequencies::FreqFunctor freqFkt,
                        DataSpace<simDim> simBoxSize) const
                {
                    using namespace mappings::threads;
                    namespace po = boost::program_options;
                    using Amplitude = picongpu::plugins::radiation::Amplitude<>;
                    constexpr uint32_t frameSize = pmacc::math::CT::volume<SuperCellSize>::type::value;
                    constexpr uint32_t numWorker = T_numWorkers;

                    using FrameType = typename ParBox::FrameType;
                    using FramePtr = typename ParBox::FramePtr;

                    using namespace parameters; // parameters of radiation

                    uint32_t const workerIdx = cupla::threadIdx(acc).x;

                    /// calculate radiated Amplitude
                    /* parallelized in 1 dimensions:
                     * looking direction (theta)
                     * (not anymore data handling)
                     * create shared memory for particle data to reduce global memory calls
                     * every thread in a block loads one particle and every thread runs
                     * through all particles and calculates the radiation for one direction
                     * for all frequencies
                     */
                    constexpr int blockSize = pmacc::math::CT::volume<SuperCellSize>::type::value;

                    // vectorial part of the integrand in the Jackson formula
                    PMACC_SMEM(acc, real_amplitude_s, memory::Array<vector_64, blockSize>);

                    // retarded time
                    PMACC_SMEM(acc, t_ret_s, memory::Array<picongpu::float_64, blockSize>);

                    // storage for macro particle weighting needed if
                    // the coherent and incoherent radiation of a single
                    // macro-particle needs to be considered
                    PMACC_SMEM(acc, radWeighting_s, memory::Array<float_X, blockSize>);

                    // particle counter used if not all particles are considered for
                    // radiation calculation
                    PMACC_SMEM(acc, counter_s, int);

                    PMACC_SMEM(acc, lowpass_s, memory::Array<NyquistLowPass, blockSize>);


                    int const theta_idx = cupla::blockIdx(acc).x; // cupla::blockIdx(acc).x is used to determine theta

                    // simulation time (needed for retarded time)
                    picongpu::float_64 const t(picongpu::float_64(currentStep) * picongpu::float_64(DELTA_T));

                    // looking direction (needed for observer) used in the thread
                    vector_64 const look = radiation_observer::observation_direction(theta_idx);

                    // get extent of guarding super cells (needed to ignore them)
                    DataSpace<simDim> const guardingSuperCells = mapper.getGuardingSuperCells();

                    /* number of super cells on GPU per dimension (still including guard cells)
                     * remove both guards from count [later one sided guard needs to be added again]
                     */
                    DataSpace<simDim> const superCellsCount(mapper.getGridSuperCells() - 2 * guardingSuperCells);

                    // get absolute number of relevant super cells
                    int const numSuperCells = superCellsCount.productOfComponents();

                    int const numJobs = cupla::gridDim(acc).y;
                    int const jobIdx = cupla::blockIdx(acc).y;

                    /* go over all super cells on GPU with a stride depending on number of temporary results
                     * but ignore all guarding supercells
                     */
                    for(int super_cell_index = jobIdx; super_cell_index <= numSuperCells; super_cell_index += numJobs)
                    {
                        // select SuperCell and add one sided guard again
                        DataSpace<simDim> const superCell
                            = DataSpaceOperations<simDim>::map(superCellsCount, super_cell_index) + guardingSuperCells;

                        // -guardingSuperCells remove guarding block
                        DataSpace<simDim> const superCellOffset(
                            globalOffset + ((superCell - guardingSuperCells) * SuperCellSize::toRT()));

                        // pointer to  frame storing particles
                        FramePtr frame = pb.getLastFrame(superCell);

                        // number  of particles in current frame
                        lcellId_t particlesInFrame = pb.getSuperCell(superCell).getSizeLastFrame();

                        /* go to next supercell
                         *
                         * if "isValid" is false then there is no frame
                         * inside the superCell (anymore)
                         */
                        while(frame.isValid())
                        {
                            /* since a race condition can occur if "continue loop" is called,
                             *  all threads must wait for the selection of a new frame
                             *  until all threads have evaluated "isValid"
                             */
                            cupla::__syncthreads(acc);

                            ForEachIdx<IdxConfig<1, numWorker>> onlyMaster{workerIdx};

                            /* The Master process (thread 0) in every thread block is in
                             * charge of loading a frame from
                             * the current super cell and evaluate the total number of
                             * particles in this frame.
                             */
                            onlyMaster([&](uint32_t const, uint32_t const) { counter_s = 0; });

                            cupla::__syncthreads(acc);

                            using ParticleDomCfg = IdxConfig<frameSize, numWorker>;

                            // loop over all particles in the frame
                            ForEachIdx<ParticleDomCfg> forEachParticle{workerIdx};

                            forEachParticle([&](uint32_t const linearIdx, uint32_t const) {
                                // only threads with particles are running
                                if(linearIdx < particlesInFrame)
                                {
                                    auto par = frame[linearIdx];
                                    // get old and new particle momenta
                                    vector_X const particle_momentumNow = vector_X(par[momentum_]);
                                    vector_X const particle_momentumOld = vector_X(par[momentumPrev1_]);
                                    /* initializes "saveParticleAt" flag with -1
                                     * because "counter_s" will never be -1
                                     * therefore, if a particle is saved, a value of counter
                                     * is stored in "saveParticleAt" != -1
                                     * THIS IS ACTUALLY ONLY NEEDED IF: the radiation flag was set
                                     * LATER: can this be optimized?
                                     */
                                    int saveParticleAt = -1;

                                    /* if particle is not accelerated we skip all calculations
                                     *
                                     * this is a component-wise comparison
                                     */
                                    if(particle_momentumNow != particle_momentumOld)
                                    {
                                        if(getRadiationMask(par))
                                            saveParticleAt = nvidia::atomicAllInc(
                                                acc,
                                                &counter_s,
                                                ::alpaka::hierarchy::Threads{});

                                        /* for information:
                                         *   atomicAdd returns an int with the previous
                                         *   value of "counter_s" != -1
                                         *   therefore, if a particle is selected
                                         *   "saveParticleAs" != -1
                                         */

                                        // if a particle needs to be considered
                                        if(saveParticleAt != -1)
                                        {
                                            // calculate global position
                                            lcellId_t const cellIdx = par[localCellIdx_];

                                            // position inside of the cell
                                            floatD_X const pos = par[position_];

                                            // calculate global position of cell
                                            DataSpace<simDim> const globalPos(
                                                superCellOffset
                                                + DataSpaceOperations<simDim>::template map<SuperCellSize>(cellIdx));

                                            // add global position of cell with local position of particle in cell
                                            vector_X particle_locationNow;
                                            // set z component to zero in case of simDim==DIM2
                                            particle_locationNow[2] = 0.0;
                                            // run over all components and compute gobal position
                                            for(int i = 0; i < simDim; ++i)
                                                particle_locationNow[i]
                                                    = (float_X(globalPos[i]) + pos[i]) * cellSize[i];

                                            /* get macro-particle weighting
                                             *
                                             * Info:
                                             * the weighting is the number of real particles described
                                             * by a macro-particle
                                             */
                                            float_X const weighting = par[weighting_];

                                            /* only of coherent and incoherent radiation of a single macro-particle is
                                             * considered, the weighting of each macro-particle needs to be stored
                                             * in order to be considered when the actual frequency calculation is done
                                             */
                                            radWeighting_s[saveParticleAt] = weighting;

                                            // mass of macro-particle
                                            float_X const particle_mass = attribute::getMass(weighting, par);

                                            /****************************************************
                                             **** Here happens the true physical calculation ****
                                             ****************************************************/

                                            // set up particle using the radiation's own particle class
                                            /*!\todo please add a namespace for Particle class*/
                                            Particle const particle(
                                                particle_locationNow,
                                                particle_momentumOld,
                                                particle_momentumNow,
                                                particle_mass);

                                            // set up amplitude calculator
                                            using Calc_Amplitude_n_sim_1 = Calc_Amplitude<Retarded_time_1, Old_DFT>;

                                            // calculate amplitude
                                            Calc_Amplitude_n_sim_1 const amplitude3(particle, DELTA_T, t);

                                            // get charge of single electron ! (weighting=1.0f)
                                            float_X const particle_charge = frame::getCharge<FrameType>();

                                            /* compute real amplitude of macro-particle with a charge of
                                             * a single electron
                                             */
                                            real_amplitude_s[saveParticleAt] = amplitude3.get_vector(look)
                                                * particle_charge * picongpu::float_64(DELTA_T);

                                            // retarded time stored in shared memory
                                            t_ret_s[saveParticleAt] = amplitude3.get_t_ret(look);

                                            lowpass_s[saveParticleAt] = NyquistLowPass(look, particle);

                                            /* the particle amplitude is used to include the weighting
                                             * of the window function filter without needing more memory
                                             */
                                            radWindowFunction::radWindowFunction const winFkt;

                                            /* start with a factor of one */
                                            float_X windowFactor = 1.0;

                                            for(uint32_t d = 0; d < simDim; ++d)
                                            {
                                                windowFactor
                                                    *= winFkt(particle_locationNow[d], simBoxSize[d] * cellSize[d]);
                                            }

                                            /* apply window function factor to amplitude */
                                            real_amplitude_s[saveParticleAt] *= windowFactor;

                                        } // END: if a particle needs to be considered
                                    } // END: check if particle is accelerated
                                } // END: only threads with particles are running
                            });

                            cupla::__syncthreads(acc); // wait till every thread has loaded its particle data


                            // run over all  valid omegas for this thread
                            for(int o = workerIdx; o < radiation_frequencies::N_omega; o += T_numWorkers)
                            {
                                /* storage for amplitude (complex 3D vector)
                                 * it  is initialized with zeros (  0 +  i 0 )
                                 * Attention: This is an accumulator and should
                                 * be in double precision to ameliorate roundoff
                                 * errors!
                                 */
                                Amplitude amplitude = Amplitude::zero();

                                // compute frequency "omega" using for-loop-index "o"
                                picongpu::float_64 const omega = freqFkt(o);

                                // create a form factor object
                                radFormFactor::radFormFactor const myRadFormFactor{};

                                /* Particle loop: thread runs through loaded particle data
                                 *
                                 * Summation of Jackson radiation formula integrand
                                 * over all electrons for fixed, thread-specific
                                 * frequency
                                 */
                                for(int j = 0; j < counter_s; ++j)
                                {
                                    // check Nyquist-limit for each particle "j" and each frequency "omega"
                                    if(lowpass_s[j].check(omega))
                                    {
                                        /****************************************************
                                         **** Here happens the true physical calculation ****
                                         ****************************************************/

                                        // calulate the form factor's' influences to the real amplitude
                                        vector_64 const weighted_real_amp = real_amplitude_s[j]
                                            * precisionCast<float_64>(myRadFormFactor(radWeighting_s[j], omega, look));

                                        /* complex amplitude increment for j-th particle
                                         * It is local to the loop and can be single precision
                                         */
                                        Amplitude amplitude_add(weighted_real_amp, t_ret_s[j] * omega);

                                        // add this single amplitude those previously considered
                                        amplitude += amplitude_add;

                                    } // END: check Nyquist-limit for each particle "j" and each frequency "omega"

                                } // END: Particle loop

                                /* the radiation contribution of the following is added to global memory:
                                 *     - valid particles of last super cell
                                 *     - from this (one) time step
                                 *     - omega_id = theta_idx * radiation_frequencies::N_omega + o
                                 */
                                radiation(DataSpace<2>(theta_idx * radiation_frequencies::N_omega + o, jobIdx))
                                    += amplitude;

                            } // end frequency loop


                            // wait till all radiation contributions for this super cell are done
                            cupla::__syncthreads(acc);

                            /* First threads starts loading next frame of the super-cell:
                             *
                             * Info:
                             *   The calculation starts with the last SuperCell (must not be full filled)
                             *   all previous SuperCells are full with particles
                             */
                            particlesInFrame = frameSize;
                            frame = pb.getPreviousFrame(frame);

                        } // end while(frame.isValid())

                    } // end loop over all super cells


                } // end radiation kernel
            };

        } // namespace radiation

    } // namespace plugins

} // namespace picongpu
