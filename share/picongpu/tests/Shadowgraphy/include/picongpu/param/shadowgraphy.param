#pragma once


#include "picongpu/simulation_defines.hpp"

#include <pmacc/dataManagement/DataConnector.hpp>
//#include "picongpu/include/picongpu/param/grid.param"


#ifndef PARAM_TRES
#    define PARAM_TRES 4
#endif
#ifndef PARAM_BANDWIDTH
#    define PARAM_BANDWIDTH 400
#endif
#ifndef PARAM_XRES
#    define PARAM_XRES 4
#endif
#ifndef PARAM_NA
#    define PARAM_NA 0.3
#endif

namespace picongpu
{
    namespace plugins
    {
        namespace shadowgraphy
        {
            namespace params
            {
                // Make sure that the Time-Bandwidth product is fulfilled @TODO
                //     omega_n = simNumT
                //     domega = 2pi / (tRes * dt)
                //     domega * omega_n * fwhm_probe[t] / 2 pi > 0.441 (for gauss)

                /** time domain parameters
                 *
                 * tRes : The time integration part of the plugin will be called each tRes'ed step
                 *  until simNumT / tRes steps after the start of the integration in the .cfg file.
                 *  Make sure that the Nyquist-Shannon theorem is fulfilled `tRes * dt * c < lambda_probe / 2`
                 *  tWfBuffer : A Tukey-like, time-domain window function with sinusoidal slopes will be applied
                 *  if tWfBuffer != 0. The sinusoidal slopes have a duration of tWfBuffer / tRes in PIConGPU
                 *  timesteps.
                 */
                constexpr unsigned int tRes = PARAM_TRES;
                constexpr unsigned int tWfBuffer = 0;

                /** position domain parameters
                 *
                 * xRes : transverse resolution of shadowgram
                 * yRes : transverse resolution of shadowgram
                 * posWfSizeX : A Tukey-like, time-domain window function with sinusoidal slopes will be
                 *  applied if posWfSizeX != 0. The slope length is posWfSizeX.
                 * posWfSizeY : A Tukey-like, time-domain window function with sinusoidal slopes will be
                 *  applied if posWfSizeY
                 * != 0. The slope length is posWfSizeY. cells.
                 */
                constexpr unsigned int xRes = PARAM_XRES;
                constexpr unsigned int yRes = PARAM_XRES;

                constexpr unsigned int posWfSize = 12;

                constexpr unsigned int posWfSizeX = posWfSize / xRes;
                constexpr unsigned int posWfSizeY = posWfSize / yRes;

                /** Fourier space parameters
                 *
                 * numericalAperture : size of the numerical aperture to remove side-scattered light
                 * numericalApertureWfSize : Sinusoidal slopes over NA * k < k_perp < (NA * k + NA * k_probe)
                 *  in the numerical aperture
                 *
                 * omegaMin : Smallest frequency for plateau value in band-pass filter
                 * omegaMax : Largest frequency for plateau value in band-pass filter
                 * omegaWfMin : Sinusoidal slopes from omegaWfMin to omegaMin, set to 0 if not required
                 * omegaWfMax : Sinusoidal slopes from omegaMax to omegaWfMax, set to 0 if not required
                 */
                constexpr float numericalAperture = PARAM_NA;
                constexpr float numericalApertureWfSize = 0.1;

                constexpr float centralLambda = 800e-9;
                constexpr float centralOmega = 2.0 * PI * SI::SPEED_OF_LIGHT_SI / centralLambda;
                constexpr float dLambda = PARAM_BANDWIDTH * 1e-9;
                constexpr float dLambdaWf = 20e-9;

                constexpr float omegaMin = 2.0 * PI * SI::SPEED_OF_LIGHT_SI / (centralLambda + dLambda);
                constexpr float omegaMax = 2.0 * PI * SI::SPEED_OF_LIGHT_SI / (centralLambda - dLambda);

                constexpr float omegaWfMin = 2.0 * PI * SI::SPEED_OF_LIGHT_SI / (centralLambda + dLambda + dLambdaWf);
                constexpr float omegaWfMax = 2.0 * PI * SI::SPEED_OF_LIGHT_SI / (centralLambda - dLambda - dLambdaWf);
            } // namespace params


            namespace masks
            {
                /** Time domain window function that will be multiplied with the electric and magnetic fields
                 * in time-position domain to reduce ringing artifacts in the omega domain after the DFT.
                 * The implemented window function is a Tukey-Window with sinusoidal slopes.
                 *
                 * @param i cell index in x direction
                 * @param j cell index in y direction
                 * @param pluginNumX amount of cells in x direction for resulting shadowgram
                 * @param pluginNumY amount of cells in y direction for resulting shadowgram
                 * @return value between 0.0 and 1.0
                 */
                HINLINE float_64 positionWf(int i, int j, int pluginNumX, int pluginNumY)
                {
                    float_64 xFactor = 1.0;

                    if(i <= params::posWfSizeX)
                    {
                        xFactor = (1.0 - math::cos(PI * i / float_64(params::posWfSizeX))) / 2.0;
                    }
                    else if((i > (pluginNumX - params::posWfSizeX)))
                    {
                        xFactor
                            = math::cos(PI * (i - (pluginNumX - params::posWfSizeX)) / float_64(params::posWfSizeX))
                                / 2.0
                            + 0.5;
                    }

                    float_64 yFactor = 1.0;

                    if(j <= params::posWfSizeY)
                    {
                        yFactor = (1.0 - math::cos(PI * j / float_64(params::posWfSizeY))) / 2.0;
                    }
                    else if((j > (pluginNumY - params::posWfSizeY)))
                    {
                        yFactor
                            = math::cos(PI * (j - (pluginNumY - params::posWfSizeY)) / float_64(params::posWfSizeY))
                                / 2.0
                            + 0.5;
                    }

                    return xFactor * yFactor;
                }

                /** Time domain window function that will be multiplied with the electric and magnetic fields
                 * in time-position domain to reduce ringing artifacts in the omega domain after the DFT.
                 * The implemented window function is a Tukey-Window with sinusoidal slopes.
                 *
                 * @param t timestep from 0 to simNumT
                 * @param simNumT amount of total time steps for time integration from plugin
                 * @return value between 0.0 and 1.0
                 */
                HINLINE float_64 timeWf(int t, int simNumT)
                {
                    float_64 tFactor = 1.0;

                    int pluginNumT = simNumT / params::tRes;
                    float pluginWfSize = params::tWfBuffer / params::tRes;

                    if(t < pluginWfSize)
                    {
                        tFactor = (1.0 - math::cos(PI * t / float_64(pluginWfSize))) / 2.0;
                    }
                    else if((t > (pluginNumT - pluginWfSize)))
                    {
                        tFactor
                            = math::cos(PI * (t - (pluginNumT - pluginWfSize)) / float_64(pluginWfSize)) / 2.0 + 0.5;
                    }

                    return tFactor;
                }


                /** Calculate filter for electric and magnetic field in Fourier space.
                 * The function returns 1 for frequencies between `params::omegaMin` and `params::omegaMax`.
                 * Furthermore, sinusoidal slopes are implemented like a Tukey window function, that reduce
                 * ringing artifacts before the inverse DFT back to time domain.
                 *
                 * @param omeganonabs frequency in SI units
                 * @return value between 0.0 and 1.0
                 */
                HINLINE float_64 frequencyFilter(float_64 omeganonabs)
                {
                    float_64 const omega = math::abs(omeganonabs);

                    float_64 const dOmegaMin = params::omegaMin - params::omegaWfMin;
                    float_64 const dOmegaMax = params::omegaWfMax - params::omegaMax;

                    if((omega >= params::omegaMin) && (omega <= params::omegaMax))
                    {
                        return 1.0;
                    }
                    else if((omega > params::omegaWfMin) && (omega < params::omegaMin))
                    {
                        return (1.0 - math::cos(PI * (omega - params::omegaMin + dOmegaMin) / dOmegaMin)) / 2.0;
                    }
                    else if((omega > params::omegaMax) && (omega < params::omegaWfMax))
                    {
                        return (1.0 + math::cos(PI * (omega - params::omegaMax) / dOmegaMax)) / 2.0;
                    }
                    else
                    {
                        return 0.0;
                    }
                }

                /** Calculate filter for electric and magnetic field in Fourier space.
                 * The function mimics the Numerical Aperture of lenses in an experimental setup by returning
                 * 0 for side-scattered light. Additionally, sinusoidal slopes are implemented like a Tukey
                 * window function to reduce ringing artifacts before the inverse DFT back to position domain.
                 *
                 * @param kx perpendicular k vector component in SI units
                 * @param ky perpendicular k vector component in SI units
                 * @param omega frequency in SI units
                 * @return value between 0.0 and 1.0
                 */
                HINLINE float_64 numericalAperture(float_64 kx, float_64 ky, float_64 omega)
                {
                    float_64 const kperp = math::sqrt(kx * kx + ky * ky);
                    float_64 const k = math::abs(omega / SI::SPEED_OF_LIGHT_SI);

                    float_64 const offsetWf
                        = params::centralOmega * params::numericalApertureWfSize / SI::SPEED_OF_LIGHT_SI;

                    float_64 const NAk = params::numericalAperture * k;

                    if(kperp <= NAk)
                    {
                        return 1.0;
                    }
                    else if(kperp <= (NAk + offsetWf))
                    {
                        return (1.0 - math::cos(PI * (kperp - NAk - offsetWf) / offsetWf)) / 2.0;
                    }
                    else
                    {
                        return 0.0;
                    }
                }

                /** Calculate filter which will be multiplied to the electric and magnetic field in Fourier space.
                 *
                 * @param kx perpendicular k vector component in SI units
                 * @param ky perpendicular k vector component in SI units
                 * @param omega frequency in SI units
                 * @return value between 0.0 and 1.0
                 */
                HINLINE float_64 maskFourier(float_64 kx, float_64 ky, float_64 omega)
                {
                    return frequencyFilter(omega) * numericalAperture(kx, ky, omega);
                }
            } // namespace masks
            // The amount of cells to remove from each (!) side of the simulation box
            // This is necessary to remove the boundary artifacts from the PIConGPU simulation
            // constexpr unsigned int x_gap = 16;
            // constexpr unsigned int y_gap = 16;

        } // namespace shadowgraphy
    } // namespace plugins
} // namespace picongpu
